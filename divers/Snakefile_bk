#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on November 2019
@author: Julie Orjuela (IRD), Aurore Comte (IRD), Sebastien Ravel (CIRAD)
"""

#
#    ,ad8888ba,   88        88  88           88888888888  88888888ba   88888888ba     ,ad8888ba,    888b      88  888888888888
#   d8"'    `"8b  88        88  88           88           88      "8b  88      "8b   d8"'    `"8b   8888b     88       88
#  d8'            88        88  88           88           88      ,8P  88      ,8P  d8'        `8b  88 `8b    88       88
#  88             88        88  88           88aaaaa      88aaaaaa8P'  88aaaaaa8P'  88          88  88  `8b   88       88
#  88             88        88  88           88"""""      88""""""8b,  88""""88'    88          88  88   `8b  88       88
#  Y8,            88        88  88           88           88      `8b  88    `8b    Y8,        ,8P  88    `8b 88       88
#   Y8a.    .a8P  Y8a.    .a8P  88           88           88      a8P  88     `8b    Y8a.    .a8P   88     `8888       88
#    `"Y8888Y"'    `"Y8888Y"'   88888888888  88888888888  88888888P"   88      `8b    `"Y8888Y"'    88      `888       88
#
#


import re, sys, glob, subprocess

################ CONFIGFILE EXTRACTION ################
configfile: 'config.yaml'

output_dir = config['DATA']['OUTPUT']
fastq = config['DATA']['FASTQ']
ref = config['DATA']['REF']
fast5 = config['DATA']['FAST5']

if 'model' in config['DATA'].keys():
    model=True
else:
    model=False

################ CHECK FILE CONFIG  ################
#if config['params']['RACON']['Racon_rounds'] >= 10:
#   raise ValueError (' Error in params "Racon_rounds" value. It must be less than 10.' )
# TODO: check des autres paramettres du fichier config
# sp = config['params']['BUSCO']['BUSCO_sp'] #checker si la sp de busco est donnée en paramettre? si oui alors ne pas mettre -sp


################ WILDCARDS  ################
FASTQ, = glob_wildcards(config['DATA']['FASTQ']+"{fastq}.fastq", followlinks=True)
#"{graph}.{ext,(pdf|png)} https://stackoverflow.com/questions/42365128/snakemake-using-regex-in-expand

ASSEMBLY_TOOLS = ["MINIASM"] #,["MINIASM","FLYE","CANU"] # se comporte comme un wildcard
POLISHING_TOOLS = ["RACON"] # se comporte comme une liste
CORRECTION_TOOLS = ["MEDAKA", "NANOPOLISH"]

# controling wildcard BUSCO_STEPS from config file params
BUSCO_STEPS = []
if config['params']['BUSCO']['BUSCO_assembly'].lower() == "yes" or config['params']['BUSCO']['BUSCO_assembly'].lower() == "y":
   BUSCO_STEPS.append("BUSCO4ASSEMBLY")
   #for assembler in ASSEMBLY_TOOLS:
   #   BUSCO_STEPS.append("BUSCO4ASSEMBLY_"+assembler)
if config['params']['BUSCO']['BUSCO_polishing'].lower() == "yes" or config['params']['BUSCO']['BUSCO_polishing'].lower() == "y" :
   for polisher in POLISHING_TOOLS:
      BUSCO_STEPS.append("BUSCO4POLISHING_"+polisher)
if config['params']['BUSCO']['BUSCO_correction'].lower() == "yes" or config['params']['BUSCO']['BUSCO_correction'].lower() == "y":
   for corrector in CORRECTION_TOOLS:
      BUSCO_STEPS.append("BUSCO4CORRECTION_"+corrector)
#print (BUSCO_STEPS)

################ FONCTIONS  ################
def recurse_draft_to_racon(wildcards):
   n = int(wildcards.nb)
   if n == 1:
      # launch racon after circularisation
      if config['DATA']['CIRCULAR'].lower() == "yes" or config['DATA']['CIRCULAR'].lower() == "y":
         return output_dir+"{fastq}/{assemblers}/CIRCULARISATION/Assembly.fasta"
      else:
         return output_dir+"{fastq}/{assemblers}/ASSEMBLER/Assembly.fasta"
   elif n > 1:
      return output_dir+"{fastq}/{assemblers}/POLISHING/RACON"+"/racon_{0}/assembly.racon{0}.fasta".format(n-1, wildcards.nb)
   else:
      raise ValueError("loop numbers must be 1 or greater: received %s" % wildcards.nb)

def draft_to_nanopolish(wildcards): # TODO  peut etre fusione avec draft_to_medaka def
   if config['params']['NANOPOLISH']['Racon_rounds'] >= 1:
      nb=str(config['params']['RACON']['Racon_rounds'])
      return output_dir+"{fastq}/{assemblers}/POLISHING/RACON/racon_"+nb+"/assembly.racon"+nb+".fasta"
   else :
      # launch racon after circularisation
      if config['DATA']['CIRCULAR'].lower() == "yes" or config['DATA']['CIRCULAR'].lower() == "y":
         return output_dir+"{fastq}/{assemblers}/CIRCULARISATION/Assembly.fasta"
      else:
         return output_dir+"{fastq}/{assemblers}/ASSEMBLER/Assembly.fasta"
         
def draft_to_medaka(wildcards):
   if config['params']['MEDAKA']['Racon_rounds'] >= 1:
      nb=str(config['params']['RACON']['Racon_rounds'])
      return output_dir+"{fastq}/{assemblers}/POLISHING/RACON/racon_"+nb+"/assembly.racon"+nb+".fasta"
   else :
      if config['DATA']['CIRCULAR'].lower() == "yes" or config['DATA']['CIRCULAR'].lower() == "y":
         return output_dir+"{fastq}/{assemblers}/CIRCULARISATION/Assembly.fasta"
      else:
         return output_dir+"{fastq}/{assemblers}/ASSEMBLER/Assembly.fasta"
       
def circularize():
    if config['DATA']['CIRCULAR'].lower() == "yes" or config['DATA']['CIRCULAR'].lower() == "y":
        return "CIRCULARISATION/assembly2Circ.fasta"
    elif config['DATA']['CIRCULAR'].lower() == "no" or config['DATA']['CIRCULAR'].lower() == "n":
        return "ASSEMBLER/Assembly.fasta"
    else:
         raise ValueError("circularize or not. That is the question.")

def add_plasmids_option(): #TODO la mettee dans run dans la rule flye
   if config['DATA']['CIRCULAR'].lower() == "yes" or config['DATA']['CIRCULAR'].lower() == "y":
      return "--plasmids "
   else:
      return " "

def circularize_for_flye():
    if config['DATA']['CIRCULAR'].lower() == "yes" or config['DATA']['CIRCULAR'].lower() == "y":
        return "CIRCULARISATION/Assembly.fasta"
    elif config['DATA']['CIRCULAR'].lower() == "no" or config['DATA']['CIRCULAR'].lower() == "n":
        return "ASSEMBLER/Assembly.fasta"
    else:
         raise ValueError("circularize or not. That is the question.")

def fasta_to_busco(wildcards):   
   #print (wildcards)
   #print (wildcards.__dict__)
   nb=str(config['params']['RACON']['Racon_rounds'])
   #busco to assembly
   if wildcards.busco_step == 'BUSCO4ASSEMBLY' :
      if config['DATA']['CIRCULAR'].lower() == "yes" or config['DATA']['CIRCULAR'].lower() == "y":
         return (output_dir+"{fastq}/{assemblers}/CIRCULARISATION/Assembly.fasta")
      else:
         return (output_dir+"{fastq}/{assemblers}/ASSEMBLER/Assembly.fasta")
   #busco to polishing
   elif (wildcards.busco_step == 'BUSCO4POLISHING_RACON') :
      return (output_dir+"{fastq}/{assemblers}/POLISHING/RACON/racon_"+nb+"/assembly.racon"+nb+".fasta")
   #busco to correction
   elif wildcards.busco_step == 'BUSCO4CORRECTION_NANOPOLISH' :     
      return (output_dir+"{fastq}/{assemblers}/CORRECTION/NANOPOLISH/consensus.fasta")
   elif wildcards.busco_step == 'BUSCO4CORRECTION_MEDAKA' :     
      return (output_dir+"{fastq}/{assemblers}/CORRECTION/MEDAKA/consensus.fasta")
   else:
      raise ValueError("problem with QUALITY BUSCO steps.")

def fasta_to_busco2(wildcards):
   import os
   # create dir containig the whole of fasta analysed and renamed
   cmd="mkdir -p "+output_dir+"QUAST/"
   #print (cmd)
   shell (cmd)

   nb=str(config['params']['RACON']['Racon_rounds'])
   #busco to assembly
   if wildcards.busco_step == 'BUSCO4ASSEMBLY' :
      if config['DATA']['CIRCULAR'].lower() == "yes" or config['DATA']['CIRCULAR'].lower() == "y":
         draft = output_dir+wildcards.fastq+'/'+wildcards.assemblers+"/CIRCULARISATION/Assembly.fasta"
         renamed = output_dir+"QUAST/"+wildcards.fastq+"."+wildcards.assemblers+"."+wildcards.busco_step+".circularised_assembly.fasta"
         cmd="cp "+draft+" "+renamed
         #print (cmd)
         shell (cmd)
         return (output_dir+"{fastq}/{assemblers}/CIRCULARISATION/Assembly.fasta")
      else:
         draft = output_dir+wildcards.fastq+'/'+wildcards.assemblers+"/ASSEMBLER/Assembly.fasta"
         renamed = output_dir+"QUAST/"+wildcards.fastq+"."+wildcards.assemblers+"."+wildcards.busco_step+".assembly.fasta"
         cmd="cp "+draft+" "+renamed
         #print (cmd)
         shell (cmd)
         return (output_dir+"{fastq}/{assemblers}/ASSEMBLER/Assembly.fasta")
   
   #busco to polishing
   elif (wildcards.busco_step == 'BUSCO4POLISHING_RACON') :
      draft = output_dir+wildcards.fastq+"/"+wildcards.assemblers+"/"+"POLISHING/RACON/racon_"+nb+"/assembly.racon"+nb+".fasta"
      renamed = output_dir+"QUAST/"+wildcards.fastq+"."+wildcards.assemblers+"."+wildcards.busco_step+nb+".assembly.fasta"
      cmd="cp "+draft+" "+renamed
      #print (cmd)
      shell (cmd)
      return (output_dir+"{fastq}/{assemblers}/POLISHING/RACON/racon_"+nb+"/assembly.racon"+nb+".fasta")
   
   #busco to correction
   elif wildcards.busco_step == 'BUSCO4CORRECTION_NANOPOLISH' :
      draft = output_dir+wildcards.fastq+"/"+wildcards.assemblers+"/CORRECTION/NANOPOLISH/polished_genome.fa"
      renamed = output_dir+"QUAST/"+wildcards.fastq+"."+wildcards.assemblers+"."+wildcards.busco_step+".corrected-nanopolish_assembly.fasta"
      cmd="cp "+draft+" "+renamed
      #print (cmd)
      shell (cmd)      
      return (output_dir+"{fastq}/{assemblers}/CORRECTION/NANOPOLISH/polished_genome.fa")
   
   elif wildcards.busco_step == 'BUSCO4CORRECTION_MEDAKA' :
      draft = output_dir+wildcards.fastq+"/"+wildcards.assemblers+"/CORRECTION/MEDAKA/consensus.fasta"
      renamed = output_dir+"QUAST/"+wildcards.fastq+"."+wildcards.assemblers+"."+wildcards.busco_step+".corrected-medaka_assembly.fasta"
      cmd="cp "+draft+" "+renamed
      #print (cmd)
      shell (cmd)      
      return (output_dir+"{fastq}/{assemblers}/CORRECTION/MEDAKA/consensus.fasta")
   else:
      raise ValueError("problem with QUALITY BUSCO steps.")

def medaka_model():
    if config['params']['MEDAKA']['MEDAKA_TRAIN_WITH_REF'].lower() == "yes" or config['params']['MEDAKA']['MEDAKA_TRAIN_WITH_REF'] == "y":
        return output_dir+"{fastq}/{assemblers}/CORRECTION/MEDAKA/training/model.best.val_cat_acc.hdf5"
    elif config['params']['MEDAKA']['MEDAKA_TRAIN_WITH_REF'].lower() == "no" or config['params']['MEDAKA']['MEDAKA_TRAIN_WITH_REF'] == "n":
        if config['params']['MEDAKA']['MEDAKA_MODEL_PATH'] != "":
            return config['params']['MEDAKA']['MEDAKA_MODEL_PATH']
        else :
            return config['params']['MEDAKA']['MEDAKA_MODEL']
    else:
        raise ValueError("problem with medaka params.")


################ RULES  ##################
rule final:
   """
   For each fastq in fastq repertory, run flye and params racon from config rounds of racon.
   """
   input:
      #POLISHING RACON
      expand(output_dir+"{fastq}/{assemblers}/POLISHING/RACON"+"/racon_{nb}/assembly.racon{nb}.fasta".format(nb=config['params']['RACON']['Racon_rounds']), fastq=FASTQ, assemblers=ASSEMBLY_TOOLS, polisher=POLISHING_TOOLS, corrector=CORRECTION_TOOLS),

      # CORRECTION TOUTCOURT
      expand(output_dir+"{fastq}/{assemblers}/CORRECTION/{corrector}/consensus.fasta", fastq=FASTQ, assemblers=ASSEMBLY_TOOLS, polisher=POLISHING_TOOLS, corrector=CORRECTION_TOOLS),

      #BUSCO
      expand(output_dir+"{fastq}/{assemblers}/QUALITY/{busco_step}/run_BUSCO_RESULTS/short_summary_BUSCO_RESULTS.txt", fastq=FASTQ, assemblers=ASSEMBLY_TOOLS, busco_step=BUSCO_STEPS, polisher=POLISHING_TOOLS, corrector=CORRECTION_TOOLS),
      
      #QUAST MARCHE PAS
      #expand (output_dir+"QUAST/quast_results/report.html", fastq=FASTQ, assemblers=ASSEMBLY_TOOLS, busco_step=BUSCO_STEPS, reference=REFERENCE, polisher=POLISHING_TOOLS, corrector=CORRECTION_TOOLS,)
      
################################ CLEAN ####################################

rule clean:
    """
    cleaning rule to snake
    """
    shell:
        """
        rm -rf output*
        """

################################ ASSEMBLY ####################################
rule run_flye:
    """
    launch flye
    """
    threads: 4
    input:
        fastq = config['DATA']['FASTQ']+"{fastq}.fastq"
    output:
        fasta_mv = output_dir+"{fastq}/FLYE/" + circularize_for_flye()
    params:
        fasta_dir = directory(output_dir+"{fastq}/FLYE/ASSEMBLER/"),
        genome_size = config['DATA']['GENOME_SIZE'],
        circular = add_plasmids_option(),
        path = config['tools']['FLYE_TOOL']
    log:
        output_dir+"{fastq}/FLYE/{fastq}.FLYE.log"
    message:
        """
        Fasta : {output.fasta_mv}
        Fastq : {input.fastq}
        Launching Flye ...
        """
    shell:
        """
        {params.path} --nano-raw {input.fastq}  --genome-size {params.genome_size} {params.circular} --out-dir {params.fasta_dir} --threads {threads}
        mv {params.fasta_dir}/assembly.fasta {output.fasta_mv}
        """

rule run_canu:
    """
    launch canu
    """
    threads: 4
    input:
        fastq = config['DATA']['FASTQ']+"{fastq}.fastq"
    output:
        fasta = output_dir+"{fastq}/CANU/ASSEMBLER/out_canu.contigs.fasta",
        fasta_mv = output_dir+"{fastq}/CANU/" + circularize()
    params:
        out_dir = directory(output_dir+"{fastq}/CANU/ASSEMBLER/"),
        genome_size = config['DATA']['GENOME_SIZE'],
        maxMemory=config['params']['CANU']['CANU_maxMemory'],
        canu=config['tools']['CANU_TOOL']
    log:
        output_dir+"{fastq}/CANU/{fastq}.CANU.log"
    message:
        """
        INPUT :
        Fastq : {input.fastq}
        OUTPUT:
        Fasta: {output.fasta}
        """
    shell:
        """
        {params.canu} -p out_canu useGrid=false maxThreads=4 maxMemory={params.maxMemory} -d {params.out_dir} genomeSize={params.genome_size} -nanopore-raw {input.fastq}
        cp {output.fasta} {output.fasta_mv}
        """

rule run_miniasm:
    """
    launch miniasm
    """
    threads: 4
    input:
        fastq = config['DATA']['FASTQ']+"{fastq}.fastq"
    output:
        temp_paf = temp(output_dir+"{fastq}/MINIASM/ASSEMBLER/output_minimap2.paf"),
        out_gfa_miniasm = output_dir+"{fastq}/MINIASM/ASSEMBLER/output_miniasm.gfa",
    params:
        path_miniasm = config['tools']['MINIASM_TOOL'],
        path_minimap2 = config['tools']['MINIMAP2_TOOL'],
    log:
        output_dir+"{fastq}/MINIASM/{fastq}.MINIASM.log"
    message:
        """
        input:
            Fastq : {input.fastq}

        Launching Miniasm ...

        output miniasm:
            gfa : {output.out_gfa_miniasm}

        """
    shell:
        """
        {params.path_minimap2} -x ava-ont -t {threads} {input.fastq} {input.fastq} > {output.temp_paf}
        {params.path_miniasm} -f {input.fastq} {output.temp_paf} > {output.out_gfa_miniasm}
        """

rule run_minipolish:
    """
    launch minipolish
    """
    threads: 4
    input:
        fastq = config['DATA']['FASTQ']+"{fastq}.fastq",
        gfa_miniasm = output_dir+"{fastq}/MINIASM/ASSEMBLER/output_miniasm.gfa"
    output:
        out_gfa_minipolish = output_dir+"{fastq}/MINIASM/ASSEMBLER/output_minipolish.gfa",
        fasta = output_dir+"{fastq}/MINIASM/" + circularize(),
    params:
        racon_rounds = config['params']['MINIPOLISH']['Racon_rounds'],
        path = config['tools']['MINIPOLISH_TOOL']
    log:
        output_dir+"{fastq}/MINIASM/ASSEMBLER/{fastq}.MINIASM.MINIPOLISH.log"
    message:
        """
        input:
            Fastq : {input.fastq}
            gfa : {input.gfa_miniasm}
        output minipolish:
            gfa : {output.out_gfa_minipolish}
            fasta : {output.fasta}

        """
    shell:
        """
        {params.path} -t {threads} --rounds {params.racon_rounds} {input.fastq} {input.gfa_miniasm} > {output.out_gfa_minipolish}
        awk '/^S/{{print \">\"$2\"\\n\"$3}}' {output.out_gfa_minipolish} | fold > {output.fasta}
        """

################################ CIRCULARISATION ####################################
rule run_circlator:
   """
   launch Circlator
   """
   threads: 4
   input:
      draft = output_dir+"{fastq}/{assemblers}/CIRCULARISATION/assembly2Circ.fasta",
      fastq = config['DATA']['FASTQ']+"{fastq}.fastq"
   output:
      fasta = output_dir+"{fastq}/{assemblers}/CIRCULARISATION/06.fixstart.fasta",
      log = output_dir+"{fastq}/{assemblers}/CIRCULARISATION/06.fixstart.log",
      fasta_mv = output_dir+"{fastq}/{assemblers}/CIRCULARISATION/Assembly.fasta",
      log_mv = output_dir+"{fastq}/{assemblers}/CIRCULARISATION/circlator.log"
   params:
      out_dir = directory(output_dir+"{fastq}/{assemblers}/CIRCULARISATION/"),
   message:
      """
      Launching Circlator ...
      input:
         fastq : {input.fastq}
         draft : {input.draft}
      output:
         fasta : {output.fasta}
         """
   singularity:
      config['tools']['CIRCLATOR_SIMG']
   shell:
      """
      circlator all --thread {threads} --verbose --bwa_opts "-x ont2d" {input.draft} {input.fastq} {params.out_dir}
      cp {output.fasta} {output.fasta_mv}
      cp {output.log} {output.log_mv}
      """


################################ POLISHING ####################################
rule run_racon:
    """
    launch Racon recursively n times (given by config.yaml)
    """
    threads: 2
    input:
        draft = recurse_draft_to_racon,
        fastq = config['DATA']['FASTQ']+"{fastq}.fastq"
    output:
        paf = output_dir+"{fastq}/{assemblers}/POLISHING/RACON/racon_{nb}/assembly.minimap4racon{nb}.paf",
        fasta = output_dir+"{fastq}/{assemblers}/POLISHING/RACON/racon_{nb}/assembly.racon{nb}.fasta"
    params:
        path_racon = config['tools']['RACON_TOOL'],
        path_minimap2 = config['tools']['MINIMAP2_TOOL'],
    wildcard_constraints:
        nb="[0-9]"
    log:
        output_dir+"{fastq}/{assemblers}/POLISHING/RACON/racon_{nb}/{fastq}.{assemblers}.RACON{nb}.log"
    message:
        """
        Launching Racon ...
        input:
            Fastq : {input.fastq}
            draft : {input.draft}

        output:
            Fasta : {output.fasta}
            paf : {output.paf}
        """
    shell:
        """
        {params.path_minimap2} -t {threads} {input.draft} {input.fastq} > {output.paf}
        {params.path_racon} -t {threads} {input.fastq} {output.paf} {input.draft} >  {output.fasta}
        """

rule run_nanopolish:
   """
   launch nanopolish
   """
   threads: 8
   input:
      draft = draft_to_nanopolish,
   output:
      temp_bam = output_dir+"{fastq}/{assemblers}/CORRECTION/NANOPOLISH/reads.sorted.bam",
      temp_fasta = output_dir+"{fastq}/{assemblers}/CORRECTION/NANOPOLISH/reads.fasta",
      vcf = output_dir+"{fastq}/{assemblers}/CORRECTION/NANOPOLISH/polished.vcf",
      fasta = output_dir+"{fastq}/{assemblers}/CORRECTION/NANOPOLISH/consensus.fasta",
   params:
      fastq = config['DATA']['FASTQ']+"{fastq}.fastq",
      fast5 = config['DATA']['FAST5'],
      directory = output_dir+"{fastq}/{assemblers}/CORRECTION/NANOPOLISH",
   singularity:
      config['tools']['NANOPOLISH_SIMG']
   log:
      output_dir+"{fastq}/{assemblers}/CORRECTION/NANOPOLISH/{fastq}.{assemblers}.NANOPOLISH.log",
   message:
      """
      Launching nanopolish ...
      input:
         draft : {input.draft}
      output:
         vcf : {output.vcf}
         Fasta : {output.fasta}
      params:
         Fast5 : {params.fast5}
         Fastq : {params.fastq}
         directory : {params.directory}
        """
   shell:
       """
       seqtk seq -A {params.fastq} > {output.temp_fasta}
       nanopolish index -d {params.fast5} {output.temp_fasta}
       minimap2 -ax map-ont -t {threads} {input.draft} {output.temp_fasta} | samtools sort -o {output.temp_bam} -T reads.tmp
       samtools index {output.temp_bam}   
       nanopolish variants --consensus -t {threads} -o {output.vcf} -r {output.temp_fasta} -b {output.temp_bam} -g {input.draft}
       nanopolish vcf2fasta --skip-checks -g {input.draft} {output.vcf} > {output.fasta}
       """

################################ QUALITY CHECK ####################################
rule run_busco:
   """
   launching BUSCO
   Assessing genome assembly and annotation completeness with Benchmarking Universal Single-Copy Orthologs (BUSCO)
   """
   threads: 4
   input:
      fasta = fasta_to_busco
   output:
      summary = output_dir+"{fastq}/{assemblers}/QUALITY/{busco_step}/run_BUSCO_RESULTS/short_summary_BUSCO_RESULTS.txt",
   params:
      directory = output_dir+"{fastq}/{assemblers}/QUALITY/{busco_step}/",
      busco_dir = "BUSCO_RESULTS",
      fasta_dir = output_dir+"QUAST/",
      database = config['params']['BUSCO']['BUSCO_database'],
      model = config['params']['BUSCO']['BUSCO_model'],
      sp = config['params']['BUSCO']['BUSCO_sp'],
      path = config['tools']['BUSCO_TOOL']
   log:
      output_dir+"{fastq}/{assemblers}/QUALITY/{busco_step}/{fastq}.{assemblers}.{busco_step}.BUSCO.log",
   message:
      """
      Launching BUSCO ...
      input:
         fasta : {input.fasta}
      output:
         summary : {output.summary}
      params:
         path : {params.path}
         database : {params.database}
         directory : {params.directory}
         busco_dir : {params.busco_dir}
         model : {params.model}
         sp : {params.sp}
         fasta_dir = {params.fasta_dir}
         
      """
   shell:
      """
      python3 {params.path} -i {input.fasta} -o {params.busco_dir} -l {params.database} -m {params.model} {params.sp} -c {threads} && mv run_BUSCO_RESULTS/ {params.directory}
      """


# rule run_quast: 
#    """
#    launching QUAST
#    """
#    threads: 2
#    input:
#       #assembly = #liste de fichiers,
#       reference = config['DATA']['REF']+"{reference}.fsa",
#    output:
#       report = output_dir+"QUAST/quast_results/report.html"
#    params:
#       genome_size = 48000000, ### TODO passer à pb virer m/g/k du param canu
#       path = config['tools']['QUAST_TOOL'],
#       directory = output_dir+"QUAST/quast_results/"
#       #ref = config['quast']['reference'],
#       #gff = config['quast']['genes_file'],
#       #options = config['quast']['options']
#    log:
#       logs = "quast.log"
#    message:
#       """
#       Launching QUAST ...
#       input:
#          fasta directory : {input.fasta_dir}
#       output:
#          report : {output.report}
#       params:
#          genome_size  : {params.genome_size}
#          path : {params.path}
#          outdir : {params.outdir}
#          #ref
#          #gff
#          #options
#       """
#    run:
#       import os
#       cmd = "%s -t %i -o %s " % (params['path'], threads, params['directory'])
#       if params['ref'] and os.path.isfile(params['ref']):
#          cmd += " -R " + params['ref']
#       if isinstance(input['assembly'], list):
#          fasta = " ".join(f for f in input['assembly'])
#       else:
#           fasta = input['assembly']
#       shell("%s %s > %s 2>&1" % (cmd, fasta, log['logs']))
#       #shell("touch {output}")
#         



################################ CORRECTION ####################################

rule run_Medaka_Train:
   """
   launching Medaka Train with fasta ref
   """
   threads: 8
   input:
      draft = draft_to_medaka,
      fastq = config['DATA']['FASTQ']+"{fastq}.fastq",
      ref = config['DATA']['REF'],### attention format fsa or fasta!
   output:
      fasta_cat_acc = output_dir+"{fastq}/{assemblers}/CORRECTION/MEDAKA/training/model.best.cat_acc.hdf5",
      fasta_val_cat_acc = output_dir+"{fastq}/{assemblers}/CORRECTION/MEDAKA/training/model.best.val_cat_acc.hdf5"
   params:
      out_name = directory(output_dir+"{fastq}/{assemblers}/CORRECTION/MEDAKA/"),
   message:
      """
      Launching Medaka_consensus
      input:
         draft : {input.draft}
         fastq : {input.fastq}
      """
   singularity:
      config['tools']['MEDAKA_SIMG']
   shell:
      """
      mini_align -t {threads} -m -r {input.draft} -i {input.fastq} -p {params.out_name}/calls2draft;
      mini_align -t {threads} -m -r {input.draft} -i {input.ref} -p {params.out_name}/truth2draft;

      medaka features {params.out_name}/calls2draft.bam {params.out_name}/train_features.hdf --truth {params.out_name}/truth2draft.bam --threads {threads} --batch_size 100 --chunk_len 1000 --chunk_ovlp 0
      medaka train {params.out_name}/train_features.hdf --train_name {params.out_name}/training --epochs 10
      
      mv {params.out_name}/training/model.best.cat_acc.hdf5 {output.fasta_cat_acc}
      mv {params.out_name}/training/model.best.val_cat_acc.hdf5 {output.fasta_val_cat_acc}
      """

if config['params']['MEDAKA']['MEDAKA_TRAIN_WITH_REF'].lower() == "no" or config['params']['MEDAKA']['MEDAKA_TRAIN_WITH_REF'] == "n":
   if config['params']['MEDAKA']['MEDAKA_MODEL_PATH'].lower() == "" :
      rule run_Medaka_Consensus:
         """
         launching Medaka Consensus
         """
         threads: 6
         input:
            draft = draft_to_medaka,
            #draft = output_dir + "{fastq}/{assemblers}/POLISHING/RACON/racon_" + str(config['params']['RACON']['Racon_rounds']) +"/assembly.racon" + str(config['params']['RACON']['Racon_rounds']) + ".fasta",
            fastq = config['DATA']['FASTQ']+"{fastq}.fastq",
         output:
            fasta_mv = output_dir+"{fastq}/{assemblers}/CORRECTION/MEDAKA/consensus.fasta"
         params:
            out_name = directory(output_dir+"{fastq}/{assemblers}/CORRECTION/MEDAKA/"),
            model = medaka_model(),
         message:
            """
            Launching Medaka_consensus
            input:
               draft : {input.draft}
               fastq : {input.fastq}
               model : {params.model}
            output:
               fasta : {output.fasta_mv}
            """
         singularity:
            config['tools']['MEDAKA_SIMG']
         shell:
            """
            medaka_consensus -t {threads} -i {input.fastq} -d {input.draft} -o {params.out_name} -m {params.model}
            """
   else:
      rule run_Medaka_Consensus:
         """
         launching Medaka Consensus
         """
         threads: 6
         input:
            draft = draft_to_medaka, 
            fastq = config['DATA']['FASTQ']+"{fastq}.fastq",
            model = medaka_model(),
         output:
            fasta_mv = output_dir+"{fastq}/{assemblers}/CORRECTION/MEDAKA/consensus.fasta"
         params:
            out_name = directory(output_dir+"{fastq}/{assemblers}/CORRECTION/MEDAKA"),
         message:
            """
            Launching Medaka_consensus
            input:
               draft : {input.draft}
               fastq : {input.fastq}
               model : {input.model}
            output:
               fasta : {output.fasta_mv}
            """
         singularity:
            config['tools']['MEDAKA_SIMG']
         shell:
            """
            medaka_consensus -t {threads} -i {input.fastq} -d {input.draft} -o {params.out_name} -m {input.model}
            """
                
elif (config['params']['MEDAKA']['MEDAKA_TRAIN_WITH_REF'].lower() == "yes" or config['params']['MEDAKA']['MEDAKA_TRAIN_WITH_REF'] == "y"):
   rule run_Medaka_Consensus:
      """
      launching Medaka Consensus
      """
      threads: 6
      input:
         draft = draft_to_medaka, 
         fastq = config['DATA']['FASTQ']+"{fastq}.fastq",
         model = medaka_model(),
      output:
         fasta_mv = output_dir+"{fastq}/{assemblers}/CORRECTION/MEDAKA/consensus.fasta"
      params:
         out_name = directory(output_dir+"{fastq}/{assemblers}/CORRECTION/MEDAKA"),
      message:
         """
         Launching Medaka_consensus
         input:
            draft : {input.draft}
            fastq : {input.fastq}
            model : {input.model}
         output:
            fasta : {output.fasta_mv}
         """
      singularity:
         config['tools']['MEDAKA_SIMG']
      shell:
         """
         medaka_consensus -t {threads} -i {input.fastq} -d {input.draft} -o {params.out_name} -m {input.model}
         """

#TODO : pouvoir accepter les .fastq mais aussi les .fq.gz, .fq ....
#TODO : lancer sur le cluster avec shell.prefix(module load $STRING)
#TODO : chercher à concatener des expands et des format() sur python3
#TODO : controler le typage des options dans le yaml. ajouter les paramettres des briques
#TODO : Minipolish aussi utilisable pour Canu et Flye?
#TODO : possibilité pour l'utilisateur de lancer les outils qu'il souhaite / ne pas lancer des outils
#TODO : Trouver une façon d'utiliser des containers ou des binaires ou les deux
#TODO : faire des containers singularity pour tous les outils ? --> les mettre sur shub pour que les utilisateurs n'aient pas besoin de compiler a chaque fois ?
#TODO : Le nombre de threads n'est pas pris en compte quand la commande est dans un container singularity